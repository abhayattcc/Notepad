<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=yes">
    <title>Kids Notepad</title>
    <style>
    * {
        box-sizing: border-box;
    }
    body {
        margin: 0;
        padding: 0;
        font-family: 'Comic Sans MS', 'Arial', sans-serif;
        background-color: #f0f8ff;
        display: flex;
        flex-direction: column;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
    }
    .container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        width: 100vw;
        position: relative;
    }
    .tabs {
        display: flex;
        background-color: #ff69b4;
        padding: 10px;
        width: 100%;
        z-index: 2;
        position: sticky;
        top: 0;
    }
    .tab {
        flex: 1;
        text-align: center;
        padding: 12px;
        color: white;
        cursor: pointer;
        font-size: 20px;
        border-radius: 8px;
        margin: 0 5px;
        background-color: #ff1493;
        transition: background-color 0.3s;
    }
    .tab.active {
        background-color: #c71585;
    }
    .tab:hover {
        background-color: #db7093;
    }
    .toolbar {
        display: flex;
        flex-wrap: wrap;
        background-color: #fffacd;
        padding: 10px;
        border-bottom: 2px solid #ffd700;
        gap: 8px;
        width: 100%;
        justify-content: center;
        z-index: 2;
    }
    .toolbar-group {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
    }
    .toolbar button {
        background-color: #7fffd4;
        border: 2px solid #20b2aa;
        border-radius: 8px;
        padding: 8px;
        font-size: 28px;
        cursor: pointer;
        width: 56px;
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.3s;
        position: relative; /* Added for tooltip positioning */
    }
    .toolbar button:hover {
        background-color: #40e0d0;
    }
    .toolbar button.active {
        background-color: #20b2aa;
    }
    .content {
        flex: 1;
        padding: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        overflow: auto;
        position: relative;
    }
    .content.fullscreen {
        padding: 0;
        width: 100%;
        height: calc(100vh - 60px);
        overflow: auto;
    }
    .content.locked {
        overflow: auto;
    }
    #textEditor, #savedTextList {
        width: 100%;
        height: 100%;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        border: none;
        resize: none;
        font-size: 16px;
        padding: 10px;
        white-space: pre-wrap;
        background: white;
        background-image: repeating-linear-gradient(0deg, transparent, transparent 29px, rgba(0,0,0,0.1) 29px, rgba(0,0,0,0.1) 30px);
        background-size: 100% 30px;
        line-height: 30px;
        outline: none;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: rgba(0,0,0,0.2) transparent;
        user-select: text;
    }
    #textEditor::-webkit-scrollbar, #savedTextList::-webkit-scrollbar {
        width: 8px;
    }
    #textEditor::-webkit-scrollbar-track, #savedTextList::-webkit-scrollbar-track {
        background: transparent;
    }
    #textEditor::-webkit-scrollbar-thumb, #savedTextList::-webkit-scrollbar-thumb {
        background-color: rgba(0,0,0,0.2);
        border-radius: 4px;
    }
    #drawingCanvas, #overlayCanvas {
        touch-action: auto;
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%;
        transition: opacity 0.5s ease-out;
    }
    #drawingCanvas.locked, #overlayCanvas.locked {
        touch-action: auto;
    }
    #overlayCanvas {
        background: transparent;
        z-index: 1;
    }
    .pen-options {
        display: flex;
        gap: 8px;
        margin-top: 8px;
    }
    .pen-options select {
        padding: 8px;
        font-size: 14px;
        border-radius: 8px;
        border: 2px solid #20b2aa;
        background-color: #f0fff0;
    }
    .pen-options input[type="color"] {
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    .hidden {
        display: none;
    }
    #savedTextList {
        overflow-y: auto;
        padding: 10px;
    }
    .saved-text-item {
        padding: 10px;
        border-bottom: 2px solid #ffd700;
        cursor: pointer;
        font-size: 16px;
        background-color: #f0fff0;
        border-radius: 8px;
        margin-bottom: 5px;
    }
    .saved-text-item:hover {
        background-color: #e6e6fa;
    }
    .page-controls {
        display: flex;
        gap: 8px;
        margin-top: 8px;
    }
    .page-controls select, .page-controls button {
        padding: 8px;
        font-size: 14px;
        border-radius: 8px;
        border: 2px solid #20b2aa;
        background-color: #f0fff0;
        cursor: pointer;
        position: relative; /* Added for tooltip positioning */
    }
    .back-button, .view-trash-button {
        position: absolute;
        padding: 8px;
        font-size: 14px;
        border-radius: 8px;
        border: 2px solid #20b2aa;
        background-color: #f0fff0;
        cursor: pointer;
    }
    .back-button {
        top: 10px;
        left: 10px;
    }
    .view-trash-button {
        top: 10px;
        right: 10px;
    }
    #progressBarContainer {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        max-width: 400px;
        background-color: #fffacd;
        border: 2px solid #ffd700;
        border-radius: 8px;
        padding: 10px;
        display: none;
        z-index: 1000;
    }
    #progressBar {
        width: 100%;
        height: 20px;
        background-color: #7fffd4;
        border-radius: 4px;
        overflow: hidden;
    }
    #progressFill {
        height: 100%;
        background-color: #20b2aa;
        width: 0%;
        transition: width 0.2s ease-in-out;
    }
    #progressText {
        text-align: center;
        font-size: 14px;
        margin-top: 5px;
        color: #333;
    }
    /* Tooltip styles */
    .tooltip {
        position: absolute;
        background-color: #333;
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
        pointer-events: none;
        top: -40px; /* Position above the button */
        left: 50%;
        transform: translateX(-50%);
        white-space: nowrap;
    }
    .tooltip.show {
        opacity: 1;
    }
    </style>
</head>
<body>
<div class="container">
    <div class="tabs" id="tabs">
        <div class="tab active" onclick="toggleSection('text')">üìù Write</div>
        <div class="tab" onclick="toggleSection('drawing')">üé® Draw</div>
    </div>
    <div class="toolbar" id="toolbar">
        <div class="toolbar-group" id="textTools">
            <button title="Undo" onclick="undoText()">‚Ü∫</button>
            <button title="Redo" onclick="redoText()">‚Üª</button>
            <button title="Find and Replace" onclick="findAndReplace()">üîé</button>
            <button title="Select All" onclick="selectAll()">üìÑ</button>
            <button title="Copy" onclick="copyText()">üìã</button>
            <button title="Erase Text" onclick="eraseText()">üßπ</button>
            <button title="Save Text" onclick="saveText()">üíæ</button>
            <button title="Show Saved Texts" onclick="showSavedTexts()">üìö</button>
            <button title="Delete Saved Text" onclick="deleteSavedText()">üóëÔ∏è</button>
            <button title="Restore Text" onclick="restoreText()">üîÑ</button>
            <button title="Permanently Delete" onclick="permanentlyDelete()">üóëÔ∏èüö´</button>
            <button title="Open File" onclick="openFile()">üìú</button>
            <button title="Export Text" onclick="exportText()">üì§</button>
        </div>
        <div class="toolbar-group hidden" id="drawingTools">
            <button title="Toggle Drawing" id="drawButton" onclick="toggleDrawing()">‚úçÔ∏è</button>
            <button title="Eraser" id="eraseButton" onclick="toggleErase()">üßπ</button>
            <button title="Lock View" id="lockButton" onclick="toggleLock()">üîí</button>
            <button title="Reset Position" onclick="resetPosition()">üîÑ</button>
            <button title="New Page" onclick="newCanvasPage()">‚ûï</button>
            <button title="Clear Current Page" onclick="clearCurrentPage()">üóëÔ∏è</button>
            <button title="Undo" onclick="undo()">‚Ü∫</button>
            <button title="Redo" onclick="redo()">‚Üª</button>
            <button title="Save as JPG" onclick="saveAsJPG()">üñºÔ∏è</button>
            <button title="Share as PDF" onclick="shareAsPDF()">üìÑ</button>
            <div class="pen-options">
                <select id="penWidth" onchange="setPenWidth(this.value)">
                    <option value="3">normal</option>
                    <option value="5">Thick</option>
                    <option value="10">Very Thick</option>
                    <option value="15">large</option>
                    <option value="25">very large</option>
                    <option value="30">Ultra Thick</option>
                </select>
                <select id="penColor" onchange="setPenColor(this.value)">
                    <option value="#ff0000">Red</option>
                    <option value="#0000ff">Blue</option>
                    <option value="#008000">Green</option>
                    <option value="#ffff00">Yellow</option>
                    <option value="#ff69b4">Pink</option>
                    <option value="#800080">Purple</option>
                    <option value="#ffa500">Orange</option>
                    <option value="#000000">Black</option>
                </select>
                <input type="color" id="colorPicker" value="#0000ff" onchange="setPenColor(this.value)">
            </div>
            <div class="page-controls">
                <button title="Previous Page" onclick="previousPage()">Previous</button>
                <select id="pageSelector" onchange="saveCanvasState(); renderPage(this.value)"></select>
                <button title="Next Page" onclick="nextPage()">Next</button>
            </div>
        </div>
    </div>
    <div class="content" id="content">
        <textarea id="textEditor"></textarea>
        <canvas id="drawingCanvas" class="hidden"></canvas>
        <canvas id="overlayCanvas" class="hidden"></canvas>
        <div id="savedTextList" class="hidden"></div>
        <div id="progressBarContainer" class="hidden">
            <div id="progressText">Loading PDF...</div>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
    // Set PDF.js worker source
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';

    // Session Storage for Drawings (temporary, cleared on reload)
    let sessionCanvasPages = {};
    let currentSection = 'text';
    let isTextCollapsed = false;
    let isDrawingCollapsed = false;
    let canvasPages = [];
    let currentPageIndex = 0;
    let isDrawing = false;
    let isErasing = false;
    let isLocked = false;
    let penWidth = 2;
    let penColor = "#0000ff";
    let savedTexts = {};
    let deletedTexts = {};
    let canvasContext = null;
    let overlayContext = null;
    let undoStack = [];
    let redoStack = [];
    let textUndoStack = [];
    let textRedoStack = [];
    let textChangeTimeout = null;
    let strokePoints = [];
    let currentPdf = null;
    let pdfPageCount = 0;
    let lastPoint = null;
    let lastTime = 0;
    let touchStartX = 0;
    let touchStartY = 0;

    // Initialize canvases
    const canvas = document.getElementById('drawingCanvas');
    const overlayCanvas = document.getElementById('overlayCanvas');
    canvasContext = canvas.getContext('2d', { willReadFrequently: true });
    overlayContext = overlayCanvas.getContext('2d', { willReadFrequently: true });
    canvasPages = [document.createElement('canvas')];
    sessionCanvasPages[`canvasPage_0`] = { dataURL: null };
    currentPageIndex = 0;
    resizeCanvas();

    // Initialize text editor
    const textEditor = document.getElementById('textEditor');
    const savedTextList = document.getElementById('savedTextList');
    textUndoStack.push({ text: '', saved: cloneState(savedTexts, deletedTexts) });
    textEditor.addEventListener('input', optimizeTextInput);

    // Tooltip functionality
    function showTooltip(button) {
        // Remove existing tooltips
        document.querySelectorAll('.tooltip').forEach(tooltip => tooltip.remove());
        
        // Create new tooltip
        const title = button.getAttribute('title');
        if (!title) return;
        
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        tooltip.textContent = title;
        button.appendChild(tooltip);
        
        // Show tooltip
        setTimeout(() => {
            tooltip.classList.add('show');
            // Remove after 2 seconds
            setTimeout(() => {
                tooltip.classList.remove('show');
                setTimeout(() => tooltip.remove(), 300);
            }, 2000);
        }, 0);
    }

    // Add click listeners to all buttons for tooltips
    document.querySelectorAll('.toolbar button, .page-controls button, .back-button, .view-trash-button').forEach(button => {
        button.addEventListener('click', () => showTooltip(button));
    });

    // IndexedDB Setup for Text Only
    const DB_NAME = 'KidsNotepadDB';
    const DB_VERSION = 1;
    let dbPromise = initIndexedDB();

    function initIndexedDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                db.createObjectStore('savedTexts', { keyPath: 'id' });
                db.createObjectStore('deletedTexts', { keyPath: 'id' });
            };

            request.onsuccess = (event) => {
                const db = event.target.result;
                if (navigator.storage && navigator.storage.persist) {
                    navigator.storage.persist().then(granted => {
                        if (granted) {
                            console.log('Persistent storage granted');
                        } else {
                            console.log('Persistent storage not granted');
                        }
                    });
                }
                resolve(db);
            };

            request.onerror = (event) => {
                console.error('IndexedDB error:', event.target.error);
                reject(event.target.error);
            };
        });
    }

    async function getAllFromStore(storeName) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = () => {
                const result = {};
                request.result.forEach(item => {
                    result[item.id] = item;
                });
                resolve(result);
            };

            request.onerror = () => reject(request.error);
        });
    }

    async function putToStore(storeName, data) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put(data);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    async function deleteFromStore(storeName, id) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(id);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    function cloneState(saved, deleted) {
        const savedStr = JSON.stringify(saved);
        const deletedStr = JSON.stringify(deleted);
        const parsedSaved = JSON.parse(savedStr);
        const parsedDeleted = JSON.parse(deletedStr);
        Object.values(parsedSaved).forEach(item => {
            if (item.date) item.date = new Date(item.date);
        });
        Object.values(parsedDeleted).forEach(item => {
            if (item.date) item.date = new Date(item.date);
            if (item.deletedDate) item.deletedDate = new Date(item.deletedDate);
        });
        return { saved: parsedSaved, deleted: parsedDeleted };
    }

    async function syncStores() {
        const db = await dbPromise;
        const txSaved = db.transaction('savedTexts', 'readwrite');
        const storeSaved = txSaved.objectStore('savedTexts');
        await new Promise((res, rej) => {
            const req = storeSaved.clear();
            req.onsuccess = () => res();
            req.onerror = () => rej(req.error);
        });
        for (const item of Object.values(savedTexts)) {
            await putToStore('savedTexts', item);
        }

        const txDeleted = db.transaction('deletedTexts', 'readwrite');
        const storeDeleted = txDeleted.objectStore('deletedTexts');
        await new Promise((res, rej) => {
            const req = storeDeleted.clear();
            req.onsuccess = () => res();
            req.onerror = () => rej(req.error);
        });
        for (const item of Object.values(deletedTexts)) {
            await putToStore('deletedTexts', item);
        }
    }

    // Initialize IndexedDB and load text data
    dbPromise.then(async db => {
        try {
            savedTexts = await getAllFromStore('savedTexts');
            deletedTexts = await getAllFromStore('deletedTexts');
            const initialState = { text: textEditor.value, ...cloneState(savedTexts, deletedTexts) };
            textUndoStack[0] = initialState;
        } catch (err) {
            console.error('Failed to load data from IndexedDB:', err);
        }
    }).catch(err => console.error('Failed to initialize IndexedDB:', err));

    // Optimize text input
    function optimizeTextInput() {
        clearTimeout(textChangeTimeout);
        textChangeTimeout = setTimeout(() => {
            if (textEditor.value !== textUndoStack[textUndoStack.length - 1].text) {
                saveTextState();
            }
        }, 300);
    }

    // Drawing, erasing, and lock toggle
    function toggleDrawing() {
        if (isLocked) return;
        isDrawing = !isDrawing;
        isErasing = false;
        const drawButton = document.getElementById('drawButton');
        const eraseButton = document.getElementById('eraseButton');
        drawButton.classList.toggle('active', isDrawing);
        eraseButton.classList.remove('active');
    }

    function toggleErase() {
        if (isLocked) return;
        isErasing = !isErasing;
        isDrawing = false;
        const drawButton = document.getElementById('drawButton');
        const eraseButton = document.getElementById('eraseButton');
        eraseButton.classList.toggle('active', isErasing);
        drawButton.classList.remove('active');
    }

    function toggleLock() {
        isLocked = !isLocked;
        const lockButton = document.getElementById('lockButton');
        const drawButton = document.getElementById('drawButton');
        const eraseButton = document.getElementById('eraseButton');
        const content = document.getElementById('content');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const overlayCanvas = document.getElementById('overlayCanvas');

        lockButton.classList.toggle('active', isLocked);
        if (isLocked) {
            isDrawing = false;
            isErasing = false;
            drawButton.classList.remove('active');
            eraseButton.classList.remove('active');
            content.classList.add('locked');
            drawingCanvas.classList.add('locked');
            overlayCanvas.classList.add('locked');
        } else {
            content.classList.remove('locked');
            drawingCanvas.classList.remove('locked');
            overlayCanvas.classList.remove('locked');
        }
    }

    function resetPosition() {
        saveCanvasState();
        resizeCanvas();
    }

    // Tab switching and collapsing
    function toggleSection(section) {
        const tabs = document.getElementById('tabs');
        const toolbar = document.getElementById('toolbar');
        const content = document.getElementById('content');

        // Save current page drawing before switching
        if (currentSection === 'drawing') {
            saveCanvasState();
        }

        if (section === 'text') {
            if (currentSection === 'text') {
                isTextCollapsed = !isTextCollapsed;
                if (isTextCollapsed) {
                    toolbar.classList.add('hidden');
                    content.classList.add('fullscreen');
                } else {
                    toolbar.classList.remove('hidden');
                    content.classList.remove('fullscreen');
                }
                showSection('text');
            } else {
                isTextCollapsed = false;
                isDrawingCollapsed = false;
                isLocked = false;
                toolbar.classList.remove('hidden');
                content.classList.remove('fullscreen');
                content.classList.remove('locked');
                document.getElementById('lockButton').classList.remove('active');
                showSection('text');
            }
        } else if (section === 'drawing') {
            if (currentSection === 'drawing') {
                isDrawingCollapsed = !isDrawingCollapsed;
                if (isDrawingCollapsed) {
                    toolbar.classList.add('hidden');
                    content.classList.add('fullscreen');
                } else {
                    toolbar.classList.remove('hidden');
                    content.classList.remove('fullscreen');
                }
                showSection('drawing');
            } else {
                isDrawingCollapsed = false;
                isTextCollapsed = false;
                isLocked = false;
                toolbar.classList.remove('hidden');
                content.classList.remove('fullscreen');
                content.classList.remove('locked');
                document.getElementById('lockButton').classList.remove('active');
                showSection('drawing');
            }
            // Always call resizeCanvas to ensure proper canvas size and drawing restoration
            resizeCanvas();
        }
    }

    function showSection(section) {
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        document.querySelector(`.tab[onclick="toggleSection('${section}')"]`).classList.add('active');
        document.getElementById('textEditor').classList.add('hidden');
        document.getElementById('drawingCanvas').classList.add('hidden');
        document.getElementById('overlayCanvas').classList.add('hidden');
        document.getElementById('savedTextList').classList.add('hidden');
        document.getElementById('progressBarContainer').classList.add('hidden');
        document.getElementById('textTools').classList.add('hidden');
        document.getElementById('drawingTools').classList.remove('hidden');
        
        if (section === 'text') {
            document.getElementById('textEditor').classList.remove('hidden');
            document.getElementById('textTools').classList.remove('hidden');
            document.getElementById('drawingTools').classList.add('hidden');
            isDrawing = false;
            isErasing = false;
            isLocked = false;
            document.getElementById('drawButton').classList.remove('active');
            document.getElementById('eraseButton').classList.remove('active');
            document.getElementById('lockButton').classList.remove('active');
            document.getElementById('content').classList.remove('locked');
            document.getElementById('drawingCanvas').classList.remove('locked');
            document.getElementById('overlayCanvas').classList.remove('locked');
        } else {
            document.getElementById('drawingCanvas').classList.remove('hidden');
            document.getElementById('overlayCanvas').classList.remove('hidden');
            // Defer resizeCanvas to ensure DOM is updated
            setTimeout(() => resizeCanvas(), 0);
        }
        currentSection = section;
        if (section === 'drawing') {
            redrawCanvas();
        }
    }

    // Text Undo/Redo Functions
    function saveTextState() {
        const state = {
            text: textEditor.value,
            ...cloneState(savedTexts, deletedTexts)
        };
        textUndoStack.push(state);
        if (textUndoStack.length > 50) textUndoStack.shift();
        textRedoStack = [];
    }

    async function undoText() {
        if (textUndoStack.length <= 1) return;
        const currentClone = cloneState(savedTexts, deletedTexts);
        const currentState = {
            text: textEditor.value,
            ...currentClone
        };
        textRedoStack.push(currentState);
        if (textRedoStack.length > 50) textRedoStack.shift();
        const prevState = textUndoStack.pop();
        textEditor.value = prevState.text;
        savedTexts = prevState.saved;
        deletedTexts = prevState.deleted;
        await syncStores();
    }

    async function redoText() {
        if (textRedoStack.length === 0) return;
        const currentClone = cloneState(savedTexts, deletedTexts);
        const currentState = {
            text: textEditor.value,
            ...currentClone
        };
        textUndoStack.push(currentState);
        if (textUndoStack.length > 50) textUndoStack.shift();
        const nextState = textRedoStack.pop();
        textEditor.value = nextState.text;
        savedTexts = nextState.saved;
        deletedTexts = nextState.deleted;
        await syncStores();
    }

    // Text Editor Functions
    function findAndReplace() {
        saveTextState();
        const find = prompt('Find what?');
        if (!find) return;
        const replace = prompt('Replace with?');
        textEditor.value = textEditor.value.replace(new RegExp(find, 'g'), replace);
        saveTextState();
    }

    function selectAll() {
        textEditor.select();
    }

    function copyText() {
        textEditor.select();
        navigator.clipboard.writeText(textEditor.value).catch(err => console.error('Copy failed:', err));
    }

    function eraseText() {
        saveTextState();
        textEditor.value = '';
        saveTextState();
    }

    async function saveText() {
        const text = textEditor.value;
        if (!text.trim()) {
            alert('Nothing to save!');
            return;
        }
        const id = Date.now().toString();
        saveTextState();
        try {
            const item = { id, text, date: new Date() };
            await putToStore('savedTexts', item);
            savedTexts[id] = item;
            alert('Text saved! ID: ' + id);
            saveTextState(); // Update state after saving
        } catch (err) {
            console.error('Failed to save text:', err);
            alert('Failed to save text!');
        }
    }

    async function showSavedTexts() {
        document.getElementById('textEditor').classList.add('hidden');
        document.getElementById('savedTextList').classList.remove('hidden');
        try {
            savedTexts = await getAllFromStore('savedTexts');
            renderTextList('view');
        } catch (err) {
            console.error('Failed to load saved texts:', err);
            alert('Failed to load saved texts!');
        }
    }

    async function renderTextList(mode) {
        const list = document.getElementById('savedTextList');
        list.innerHTML = '';
        const texts = mode === 'permanentlyDelete' || mode === 'restore' ? deletedTexts : savedTexts;
        const isEmpty = Object.keys(texts).length === 0;
        
        if (isEmpty) {
            const div = document.createElement('div');
            div.className = 'saved-text-item';
            div.innerText = mode === 'permanentlyDelete' || mode === 'restore' ? 'No texts in trash!' : 'No saved texts!';
            list.appendChild(div);
        } else {
            for (const id in texts) {
                const div = document.createElement('div');
                div.className = 'saved-text-item';
                div.innerText = `ID: ${id} | Date: ${new Date(texts[id].date).toLocaleString()} | ${texts[id].text.slice(0, 50)}...`;
                div.onclick = async () => {
                    if (mode === 'delete') {
                        saveTextState();
                        try {
                            deletedTexts[id] = { ...savedTexts[id], deletedDate: new Date() };
                            await putToStore('deletedTexts', deletedTexts[id]);
                            await deleteFromStore('savedTexts', id);
                            delete savedTexts[id];
                            alert('Text moved to trash!');
                            renderTextList('delete');
                        } catch (err) {
                            console.error('Failed to delete text:', err);
                            alert('Failed to delete text!');
                        }
                    } else if (mode === 'restore') {
                        const now = new Date();
                        const deletedDate = new Date(deletedTexts[id].deletedDate || deletedTexts[id].date);
                        const daysDiff = (now - deletedDate) / (1000 * 60 * 60 * 24);
                        if (daysDiff > 60) {
                            alert('Text is older than 60 days!');
                            return;
                        }
                        saveTextState();
                        try {
                            savedTexts[id] = { ...deletedTexts[id] };
                            await putToStore('savedTexts', savedTexts[id]);
                            await deleteFromStore('deletedTexts', id);
                            delete deletedTexts[id];
                            textEditor.value = savedTexts[id].text;
                            saveTextState();
                            alert('Text restored!');
                            showSection('text');
                        } catch (err) {
                            console.error('Failed to restore text:', err);
                            alert('Failed to restore text!');
                        }
                    } else if (mode === 'permanentlyDelete') {
                        saveTextState();
                        try {
                            await deleteFromStore('deletedTexts', id);
                            delete deletedTexts[id];
                            alert('Text permanently deleted!');
                            renderTextList('permanentlyDelete');
                        } catch (err) {
                            console.error('Failed to permanently delete text:', err);
                            alert('Failed to permanently delete text!');
                        }
                    } else {
                        saveTextState();
                        textEditor.value = savedTexts[id].text;
                        saveTextState();
                        showSection('text');
                    }
                };
                list.appendChild(div);
            }
        }
        
        const backButton = document.createElement('button');
        backButton.className = 'back-button';
        backButton.innerText = 'Back';
        backButton.title = 'Back to Text Editor';
        backButton.onclick = () => showSection('text');
        list.insertBefore(backButton, list.firstChild);

        if (mode === 'restore') {
            const viewTrashButton = document.createElement('button');
            viewTrashButton.className = 'view-trash-button';
            viewTrashButton.innerText = 'View Trash';
            viewTrashButton.title = 'View Deleted Texts';
            viewTrashButton.onclick = () => renderTextList('permanentlyDelete');
            list.insertBefore(viewTrashButton, list.firstChild);
        }
    }

    async function deleteSavedText() {
        document.getElementById('textEditor').classList.add('hidden');
        document.getElementById('savedTextList').classList.remove('hidden');
        try {
            savedTexts = await getAllFromStore('savedTexts');
            renderTextList('delete');
        } catch (err) {
            console.error('Failed to load saved texts:', err);
            alert('Failed to load saved texts!');
        }
    }

    async function restoreText() {
        document.getElementById('textEditor').classList.add('hidden');
        document.getElementById('savedTextList').classList.remove('hidden');
        try {
            deletedTexts = await getAllFromStore('deletedTexts');
            renderTextList('restore');
        } catch (err) {
            console.error('Failed to load deleted texts:', err);
            alert('Failed to load deleted texts!');
        }
    }

    async function permanentlyDelete() {
        document.getElementById('textEditor').classList.add('hidden');
        document.getElementById('savedTextList').classList.remove('hidden');
        try {
            deletedTexts = await getAllFromStore('deletedTexts');
            renderTextList('permanentlyDelete');
        } catch (err) {
            console.error('Failed to load deleted texts:', err);
            alert('Failed to load deleted texts!');
        }
    }

    function exportText() {
        const text = textEditor.value;
        const blob = new Blob([text], { type: 'text/plain' });
        downloadFile(blob, 'notepad.txt');
    }

    // File Handling
    async function openFile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/pdf,.txt';
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            saveTextState();
            const progressBarContainer = document.getElementById('progressBarContainer');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            progressBarContainer.classList.remove('hidden');
            progressFill.style.width = '0%';
            progressText.textContent = 'Loading file...';

            if (file.type === 'text/plain') {
                progressText.textContent = 'Loading text file...';
                const text = await file.text();
                textEditor.value = text;
                saveTextState();
                progressBarContainer.classList.add('hidden');
                showSection('text');
            } else if (file.type === 'application/pdf') {
                try {
                    // Clear previous session data
                    currentPdf = null;
                    pdfPageCount = 0;
                    canvasPages = [document.createElement('canvas')];
                    sessionCanvasPages = { 'canvasPage_0': { dataURL: null } };
                    currentPageIndex = 0;
                    undoStack = [];
                    redoStack = [];
                    overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                    const arrayBuffer = await file.arrayBuffer();
                    const loadingTask = pdfjsLib.getDocument({
                        data: arrayBuffer,
                        disableAutoFetch: true,
                        disableStream: true,
                        disableFontFace: true,
                        nativeImageDecoderSupport: 'decode',
                        maxImageSize: 1024 * 1024,
                        isEvalSupported: false
                    });

                    let totalSteps = 2;
                    let currentStep = 0;

                    function updateProgress(step, total) {
                        currentStep = step;
                        const percent = Math.min(100, (currentStep / total) * 100);
                        progressFill.style.width = `${percent}%`;
                        progressText.textContent = `Processing PDF (${currentStep}/${total})...`;
                    }

                    updateProgress(0, totalSteps);
                    loadingTask.onProgress = (progress) => {
                        if (progress.total) {
                            const percent = Math.min(100, (progress.loaded / progress.total) * 50);
                            progressFill.style.width = `${percent}%`;
                        }
                    };

                    currentPdf = await loadingTask.promise;
                    pdfPageCount = currentPdf.numPages;
                    updateProgress(1, totalSteps);

                    let textContent = '';
                    for (let i = 1; i <= pdfPageCount; i++) {
                        const page = await currentPdf.getPage(i);
                        const text = await page.getTextContent();
                        textContent += text.items.map(item => item.str + (item.hasEOL ? '\n' : ' ')).join('');
                        if (i < pdfPageCount) textContent += '\n\n';
                    }
                    textContent = textContent.trim();

                    if (textContent.length > 0) {
                        textEditor.value = textContent;
                        saveTextState();
                        updateProgress(2, totalSteps);
                        progressBarContainer.classList.add('hidden');
                        showSection('text');
                        currentPdf = null;
                    } else {
                        totalSteps = pdfPageCount + 2;
                        updateProgress(2, totalSteps);

                        const selector = document.getElementById('pageSelector');
                        selector.innerHTML = '';
                        for (let i = 1; i <= pdfPageCount; i++) {
                            const option = document.createElement('option');
                            option.value = i;
                            option.text = `Page ${i}`;
                            selector.appendChild(option);
                        }
                        canvasPages = Array(pdfPageCount).fill().map(() => document.createElement('canvas'));
                        for (let i = 0; i < pdfPageCount; i++) {
                            sessionCanvasPages[`canvasPage_${i}`] = { dataURL: null };
                        }
                        progressBarContainer.classList.add('hidden');
                        isLocked = true;
                        document.getElementById('lockButton').classList.add('active');
                        document.getElementById('content').classList.add('locked');
                        document.getElementById('drawingCanvas').classList.add('locked');
                        document.getElementById('overlayCanvas').classList.add('locked');
                        showSection('drawing');
                        renderPage(1);
                    }
                } catch (err) {
                    console.error('PDF loading failed:', err);
                    progressBarContainer.classList.add('hidden');
                    let errorMessage = 'Failed to load PDF!';
                    if (err.name === 'InvalidPDFException') {
                        errorMessage = 'Invalid or corrupted PDF file!';
                    } else if (err.message.includes('network')) {
                        errorMessage = 'Network error: Please check your connection or try again!';
                    }
                    alert(errorMessage);
                    currentPdf = null;
                }
            }
        };
        input.click();
    }

    function previousPage() {
        if (currentPageIndex > 0) {
            saveCanvasState();
            currentPageIndex--;
            document.getElementById('pageSelector').value = currentPageIndex + 1;
            renderPage(currentPageIndex + 1);
        }
    }

    function nextPage() {
        if (currentPageIndex < canvasPages.length - 1) {
            saveCanvasState();
            currentPageIndex++;
            document.getElementById('pageSelector').value = currentPageIndex + 1;
            renderPage(currentPageIndex + 1);
        }
    }

    async function renderPage(pageNum) {
        currentPageIndex = pageNum - 1;
        const content = document.querySelector('.content');
        let imgWidth = content.offsetWidth;
        let imgHeight = content.offsetHeight;

        if (currentPdf && currentPageIndex < pdfPageCount) {
            const page = await currentPdf.getPage(pageNum);
            const viewport = page.getViewport({ scale: 3 });
            imgWidth = viewport.width;
            imgHeight = viewport.height;
            canvasPages[currentPageIndex].width = imgWidth;
            canvasPages[currentPageIndex].height = imgHeight;
            const ctx = canvasPages[currentPageIndex].getContext('2d', { willReadFrequently: true });
            ctx.clearRect(0, 0, imgWidth, imgHeight);
            await page.render({
                canvasContext: ctx,
                viewport: viewport,
                enableWebGL: true
            }).promise;
        } else {
            canvasPages[currentPageIndex].width = imgWidth;
            canvasPages[currentPageIndex].height = imgHeight;
            const ctx = canvasPages[currentPageIndex].getContext('2d', { willReadFrequently: true });
            drawBackground(ctx);
        }

        canvas.width = imgWidth;
        canvas.height = imgHeight;
        overlayCanvas.width = imgWidth;
        overlayCanvas.height = imgHeight;
        canvasPages[currentPageIndex].width = canvas.width;
        canvasPages[currentPageIndex].height = canvas.height;

        const savedCanvas = sessionCanvasPages[`canvasPage_${currentPageIndex}`];
        if (savedCanvas && savedCanvas.dataURL) {
            const img = new Image();
            img.src = savedCanvas.dataURL;
            img.onload = () => {
                overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                overlayContext.drawImage(img, 0, 0, overlayCanvas.width, overlayCanvas.height);
                redrawCanvas();
            };
            img.onerror = () => {
                overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                redrawCanvas();
            };
        } else {
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            redrawCanvas();
        }
    }

    // File download helper
    function downloadFile(blob, filename) {
        try {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        } catch (err) {
            console.error('Download failed:', err);
            alert('Failed to download file. Please try again.');
        }
    }

    // Save as JPG
    async function saveAsJPG() {
        saveCanvasState();
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const ctx = tempCanvas.getContext('2d');

        if (currentPdf && currentPageIndex < pdfPageCount) {
            const page = await currentPdf.getPage(currentPageIndex + 1);
            const viewport = page.getViewport({ scale: 3 });
            tempCanvas.width = viewport.width;
            tempCanvas.height = viewport.height;
            await page.render({
                canvasContext: ctx,
                viewport: viewport,
                enableWebGL: true
            }).promise;
        } else {
            drawBackground(ctx);
        }

        ctx.drawImage(overlayCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
        const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png', 0.95));
        downloadFile(blob, `drawing_page_${currentPageIndex + 1}.jpg`);
    }

    // Share as PDF
    async function shareAsPDF() {
        saveCanvasState();
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'px',
            format: 'a4'
        });
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();

        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        progressBarContainer.classList.remove('hidden');
        progressFill.style.width = '0%';
        progressText.textContent = 'Generating PDF...';

        for (let i = 0; i < canvasPages.length; i++) {
            if (i > 0) doc.addPage();
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvasPages[i].width;
            tempCanvas.height = canvasPages[i].height;
            const ctx = tempCanvas.getContext('2d');

            if (currentPdf && i < pdfPageCount) {
                const page = await currentPdf.getPage(i + 1);
                const viewport = page.getViewport({ scale: 3 });
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                await page.render({
                    canvasContext: ctx,
                    viewport: viewport,
                    enableWebGL: true
                }).promise;
            } else {
                drawBackground(ctx);
            }

            const savedCanvas = sessionCanvasPages[`canvasPage_${i}`];
            if (savedCanvas && savedCanvas.dataURL) {
                const img = new Image();
                await new Promise(resolve => {
                    img.src = savedCanvas.dataURL;
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                        resolve();
                    };
                    img.onerror = () => resolve();
                });
            }

            const imgData = tempCanvas.toDataURL('image/jpeg', 0.95);
            const imgProps = doc.getImageProperties(imgData);
            const imgWidth = pageWidth - 20;
            const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
            const yPos = (pageHeight - imgHeight) / 2;
            doc.addImage(imgData, 'JPEG', 10, yPos, imgWidth, imgHeight);

            const percent = ((i + 1) / canvasPages.length) * 100;
            progressFill.style.width = `${percent}%`;
            progressText.textContent = `Generating PDF (${i + 1}/${canvasPages.length})...`;
        }

        progressBarContainer.classList.add('hidden');
        const blob = doc.output('blob');
        downloadFile(blob, 'notepad_drawing.pdf');
    }

    // Canvas Drawing
    function resizeCanvas() {
        const content = document.querySelector('.content');
        let imgWidth = content.offsetWidth;
        let imgHeight = content.offsetHeight;

        if (currentPdf && currentPageIndex < pdfPageCount) {
            // For PDF pages, use the stored dimensions
            imgWidth = canvasPages[currentPageIndex].width || imgWidth;
            imgHeight = canvasPages[currentPageIndex].height || imgHeight;
        }

        // Only resize if dimensions have changed
        if (canvas.width !== imgWidth || canvas.height !== imgHeight ||
            overlayCanvas.width !== imgWidth || overlayCanvas.height !== imgHeight) {
            canvas.width = imgWidth;
            canvas.height = imgHeight;
            overlayCanvas.width = imgWidth;
            overlayCanvas.height = imgHeight;
            canvasPages[currentPageIndex].width = imgWidth;
            canvasPages[currentPageIndex].height = imgHeight;

            // Clear the contexts
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            // Restore the drawing from session storage
            const savedCanvas = sessionCanvasPages[`canvasPage_${currentPageIndex}`];
            if (savedCanvas && savedCanvas.dataURL) {
                const img = new Image();
                img.src = savedCanvas.dataURL;
                img.onload = () => {
                    overlayContext.drawImage(img, 0, 0, overlayCanvas.width, overlayCanvas.height);
                    redrawCanvas();
                };
                img.onerror = () => {
                    overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                    redrawCanvas();
                };
            } else {
                redrawCanvas();
            }
        } else {
            // If no resize is needed, still ensure the drawing is restored
            const savedCanvas = sessionCanvasPages[`canvasPage_${currentPageIndex}`];
            if (savedCanvas && savedCanvas.dataURL) {
                const img = new Image();
                img.src = savedCanvas.dataURL;
                img.onload = () => {
                    overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                    overlayContext.drawImage(img, 0, 0, overlayCanvas.width, overlayCanvas.height);
                    redrawCanvas();
                };
                img.onerror = () => {
                    overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                    redrawCanvas();
                };
            } else {
                overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                redrawCanvas();
            }
        }
    }

    function addCanvasPage() {
        saveCanvasState();
        const content = document.querySelector('.content');
        const newCanvas = document.createElement('canvas');
        newCanvas.width = content.offsetWidth;
        newCanvas.height = content.offsetHeight;
        canvasPages.splice(currentPageIndex + 1, 0, newCanvas);
        sessionCanvasPages[`canvasPage_${currentPageIndex + 1}`] = { dataURL: null };
        currentPageIndex = currentPageIndex + 1;
        const selector = document.getElementById('pageSelector');
        selector.innerHTML = '';
        for (let i = 1; i <= canvasPages.length; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.text = `Page ${i}`;
            selector.appendChild(option);
        }
        selector.value = currentPageIndex + 1;
        undoStack = [];
        redoStack = [];
        overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        redrawCanvas();
    }

    function newCanvasPage() {
        addCanvasPage();
        resizeCanvas();
    }

    function clearCurrentPage() {
        // Save the current state before clearing
        const dataURL = overlayCanvas.toDataURL();
        undoStack.push({ dataURL, points: [], bounds: null });
        if (undoStack.length > 50) undoStack.shift();
        redoStack = [];

        overlayCanvas.style.opacity = '0';
        setTimeout(() => {
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            sessionCanvasPages[`canvasPage_${currentPageIndex}`] = { dataURL: overlayCanvas.toDataURL() };
            overlayCanvas.style.opacity = '1';
            const currentCanvas = canvasPages[currentPageIndex];
            const ctx = currentCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, currentCanvas.width, currentCanvas.height).data;
            const isEmpty = Array.from(imageData).every(pixel => pixel === 0 || pixel === 255);
            if (isEmpty && canvasPages.length > 1 && currentPageIndex >= pdfPageCount) {
                canvasPages.splice(currentPageIndex, 1);
                delete sessionCanvasPages[`canvasPage_${currentPageIndex}`];
                if (currentPageIndex >= canvasPages.length) {
                    currentPageIndex = canvasPages.length - 1;
                }
                const selector = document.getElementById('pageSelector');
                selector.innerHTML = '';
                for (let i = 1; i <= canvasPages.length; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.text = `Page ${i}`;
                    selector.appendChild(option);
                }
                selector.value = currentPageIndex + 1;
                renderPage(currentPageIndex + 1);
            } else {
                redrawCanvas();
            }
        }, 500);
    }

    function setPenWidth(width) {
        penWidth = parseInt(width);
    }

    function setPenColor(color) {
        penColor = color;
        document.getElementById('colorPicker').value = color;
        document.getElementById('penColor').value = color;
    }

    function saveCanvasState(points = []) {
        const dataURL = overlayCanvas.toDataURL();
        const bounds = points.length > 0 ? calculateStrokeBounds(points) : null;
        undoStack.push({ dataURL, points, bounds });
        if (undoStack.length > 50) undoStack.shift();
        sessionCanvasPages[`canvasPage_${currentPageIndex}`] = { dataURL };
    }

    function calculateStrokeBounds(points) {
        if (points.length === 0) return null;
        let minX = points[0].x, maxX = points[0].x;
        let minY = points[0].y, maxY = points[0].y;
        points.forEach(point => {
            minX = Math.min(minX, point.x);
            maxX = Math.max(maxX, point.x);
            minY = Math.min(minY, point.y);
            maxY = Math.max(maxY, point.y);
        });
        return { minX, maxX, minY, maxY };
    }

    function undo() {
        if (undoStack.length === 0) return;
        if (undoStack.length === 1) {
            const currentState = overlayCanvas.toDataURL();
            redoStack.push({ dataURL: currentState, points: [], bounds: null });
            if (redoStack.length > 50) redoStack.shift();
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            sessionCanvasPages[`canvasPage_${currentPageIndex}`] = { dataURL: overlayCanvas.toDataURL() };
            undoStack = [];
            redrawCanvas();
            return;
        }
        const currentState = overlayCanvas.toDataURL();
        redoStack.push({ dataURL: currentState, points: [], bounds: null });
        if (redoStack.length > 50) redoStack.shift();
        const prevState = undoStack.pop();
        const img = new Image();
        img.src = prevState.dataURL;
        img.onload = () => {
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            overlayContext.drawImage(img, 0, 0, overlayCanvas.width, overlayCanvas.height);
            sessionCanvasPages[`canvasPage_${currentPageIndex}`] = { dataURL: overlayCanvas.toDataURL() };
            redrawCanvas();
            isDrawing = true;
            isErasing = false;
            document.getElementById('drawButton').classList.add('active');
            document.getElementById('eraseButton').classList.remove('active');
        };
    }

    function redo() {
        if (redoStack.length === 0) return;
        const currentState = overlayCanvas.toDataURL();
        undoStack.push({ dataURL: currentState, points: [], bounds: null });
        if (undoStack.length > 50) undoStack.shift();
        const nextState = redoStack.pop();
        const img = new Image();
        img.src = nextState.dataURL;
        img.onload = () => {
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            overlayContext.drawImage(img, 0, 0, overlayCanvas.width, overlayCanvas.height);
            sessionCanvasPages[`canvasPage_${currentPageIndex}`] = { dataURL: overlayCanvas.toDataURL() };
            redrawCanvas();
        };
    }

    function drawBackground(ctx) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        for (let y = 30; y < ctx.canvas.height; y += 30) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(ctx.canvas.width, y);
            ctx.stroke();
        }
    }

    async function redrawCanvas() {
        if (canvas.width === 0 || canvas.height === 0) return;
        if (currentPdf && currentPageIndex < pdfPageCount) {
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);
            const page = await currentPdf.getPage(currentPageIndex + 1);
            const viewport = page.getViewport({ scale: 3 });
            await page.render({
                canvasContext: canvasContext,
                viewport: viewport,
                enableWebGL: true
            }).promise;
        } else {
            drawBackground(canvasContext);
        }
    }

    // Smooth Drawing Logic
    function getCoordinates(e) {
        const rect = overlayCanvas.getBoundingClientRect();
        const scaleX = overlayCanvas.width / rect.width;
        const scaleY = overlayCanvas.height / rect.height;
        let x, y;
        if (e.type.startsWith('touch')) {
            x = (e.touches[0].clientX - rect.left) * scaleX;
            y = (e.touches[0].clientY - rect.top) * scaleY;
        } else {
            x = (e.clientX - rect.left) * scaleX;
            y = (e.clientY - rect.top) * scaleY;
        }
        return { x, y, time: Date.now() };
    }

    function drawStroke(currentPoint) {
        if (!lastPoint) return;

        overlayContext.lineCap = 'round';
        overlayContext.lineJoin = 'round';
        overlayContext.strokeStyle = penColor;
        overlayContext.lineWidth = penWidth;
        overlayContext.globalAlpha = 1;

        const deltaTime = currentPoint.time - lastTime;
        const speed = Math.sqrt(
            Math.pow(currentPoint.x - lastPoint.x, 1) +
            Math.pow(currentPoint.y - lastPoint.y, 1)
        ) / (deltaTime || 1);
        const dynamicWidth = Math.max(1, Math.min(penWidth, penWidth / (1 + speed * 0.1)));

        overlayContext.beginPath();
        overlayContext.moveTo(lastPoint.x, lastPoint.y);
        overlayContext.lineTo(currentPoint.x, currentPoint.y);
        overlayContext.lineWidth = dynamicWidth;
        overlayContext.stroke();
        overlayContext.globalAlpha = 1;
    }

    function eraseStroke(x, y) {
        const eraseRadius = penWidth * 15;
        overlayContext.globalCompositeOperation = 'destination-out';
        overlayContext.beginPath();
        overlayContext.arc(x, y, eraseRadius, 0, Math.PI * 2);
        overlayContext.fill();
        overlayContext.globalCompositeOperation = 'source-over';
    }

    function addPoint(e) {
        if (!isDrawing && !isErasing || currentSection !== 'drawing' || isLocked) return;
        const point = getCoordinates(e);
        strokePoints.push(point);

        if (isDrawing) {
            point.color = penColor;
            point.width = penWidth;
            drawStroke(point);
            lastPoint = point;
            lastTime = point.time;
        } else if (isErasing) {
            eraseStroke(point.x, point.y);
        }
        e.preventDefault();
    }

    // Drawing and Swipe Event Listeners
    overlayCanvas.addEventListener('mousedown', (e) => {
        if (currentSection === 'drawing' && !isLocked) {
            if (e.button === 0) {
                isDrawing = true;
                isErasing = false;
                document.getElementById('drawButton').classList.add('active');
                document.getElementById('eraseButton').classList.remove('active');
                lastPoint = getCoordinates(e);
                lastTime = lastPoint.time;
                strokePoints = [lastPoint];
            } else if (e.button === 2) {
                isErasing = true;
                isDrawing = false;
                document.getElementById('eraseButton').classList.add('active');
                document.getElementById('drawButton').classList.remove('active');
                const point = getCoordinates(e);
                strokePoints = [point];
                eraseStroke(point.x, point.y);
            }
            e.preventDefault();
        }
    });

    overlayCanvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });

    overlayCanvas.addEventListener('mousemove', (e) => {
        if (currentSection === 'drawing' && !isLocked) {
            if (isDrawing) {
                addPoint(e);
            } else if (isErasing) {
                const point = getCoordinates(e);
                strokePoints.push(point);
                eraseStroke(point.x, point.y);
            }
        }
    });

    overlayCanvas.addEventListener('mouseup', (e) => {
        if (currentSection === 'drawing' && !isLocked && (isDrawing || isErasing) && strokePoints.length > 0) {
            saveCanvasState(strokePoints);
            redoStack = [];
            strokePoints = [];
            lastPoint = null;
        }
    });

    overlayCanvas.addEventListener('touchstart', (e) => {
        if (currentSection === 'drawing') {
            if (isLocked && e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (!isLocked && e.touches.length === 1) {
                isDrawing = true;
                isErasing = false;
                document.getElementById('drawButton').classList.add('active');
                document.getElementById('eraseButton').classList.remove('active');
                lastPoint = getCoordinates(e);
                lastTime = lastPoint.time;
                strokePoints = [lastPoint];
            } else if (!isLocked && e.touches.length === 2) {
                isErasing = true;
                isDrawing = false;
                document.getElementById('eraseButton').classList.add('active');
                document.getElementById('drawButton').classList.remove('active');
                const point = getCoordinates(e);
                strokePoints = [point];
                eraseStroke(point.x, point.y);
            } else if (!isLocked && e.touches.length === 4) {
                penColor = '#' + Math.floor(Math.random() * 16777215).toString(16);
                setPenColor(penColor);
                isDrawing = true;
                isErasing = false;
                document.getElementById('drawButton').classList.add('active');
                document.getElementById('eraseButton').classList.remove('active');
                const point = getCoordinates(e);
                lastPoint = point;
                lastTime = point.time;
                strokePoints = [point];
            } else if (!isLocked && e.touches.length === 3) {
                undo();
                e.preventDefault();
                return;
            }
            e.preventDefault();
        }
    });

    overlayCanvas.addEventListener('touchmove', (e) => {
        if (currentSection === 'drawing' && !isLocked && (e.touches.length === 1 || e.touches.length === 2 || e.touches.length === 4)) {
            addPoint(e);
            e.preventDefault();
        }
    });

    overlayCanvas.addEventListener('touchend', (e) => {
        if (currentSection === 'drawing' && isLocked && e.changedTouches.length === 1) {
            const touchEndX = e.changedTouches[0].clientX;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchStartY - e.changedTouches[0].clientY;
            const swipeThreshold = 100;
            if (Math.abs(deltaX) > swipeThreshold && Math.abs(deltaY) < swipeThreshold) {
                if (deltaX > 0) {
                    previousPage();
                } else {
                    nextPage();
                }
            }
        } else if (currentSection === 'drawing' && !isLocked && e.changedTouches.length >= 1 && (isDrawing || isErasing) && strokePoints.length > 0) {
            saveCanvasState(strokePoints);
            redoStack = [];
            strokePoints = [];
            lastPoint = null;
        }
        e.preventDefault();
    });

    overlayCanvas.addEventListener('wheel', (e) => {
        if (!isLocked) e.preventDefault();
    });

    // Window resize handling
    window.addEventListener('resize', () => {
        if (currentSection === 'drawing') {
            saveCanvasState();
            resizeCanvas();
        }
    });
</script>
</body>
</html>