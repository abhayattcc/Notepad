<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=yes">
    <title>Kids Notepad</title>
    <style>
    * {
        box-sizing: border-box;
    }
    body {
        margin: 0;
        padding: 0;
        font-family: 'Comic Sans MS', 'Arial', sans-serif;
        background-color: #f0f8ff;
        display: flex;
        flex-direction: column;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
    }
    .container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        width: 100vw;
        position: relative;
    }
    .tabs {
        display: flex;
        background-color: #ff69b4;
        padding: 10px;
        width: 100%;
        z-index: 2;
        position: sticky;
        top: 0;
    }
    .tab {
        flex: 1;
        text-align: center;
        padding: 12px;
        color: white;
        cursor: pointer;
        font-size: 20px;
        border-radius: 8px;
        margin: 0 5px;
        background-color: #ff1493;
        transition: background-color 0.3s;
    }
    .tab.active {
        background-color: #c71585;
    }
    .tab:hover {
        background-color: #db7093;
    }
    .toolbar {
        display: flex;
        flex-wrap: wrap;
        background-color: #fffacd;
        padding: 10px;
        border-bottom: 2px solid #ffd700;
        gap: 8px;
        width: 100%;
        justify-content: center;
        z-index: 2;
    }
    .toolbar-group {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
    }
    .toolbar button {
        background-color: #7fffd4;
        border: 2px solid #20b2aa;
        border-radius: 8px;
        padding: 8px;
        font-size: 28px;
        cursor: pointer;
        width: 56px;
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.3s;
    }
    .toolbar button:hover {
        background-color: #40e0d0;
    }
    .toolbar button.active {
        background-color: #20b2aa;
    }
    .content {
        flex: 1;
        padding: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        overflow: auto;
        position: relative;
    }
    .content.fullscreen {
        padding: 10px;
        width: 100%;
        height: calc(100vh - 60px);
        overflow: auto;
    }
    .content.locked {
        overflow: auto;
    }
    #textEditor, #savedTextList {
        width: 100%;
        height: 100%;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        border: none;
        resize: none;
        font-size: 16px;
        padding: 10px;
        white-space: pre-wrap;
        background: white;
        background-size: 100% 30px;
        line-height: 30px;
        outline: none;
        overflow-y: auto;
        scroll-behavior: smooth;
        scrollbar-width: auto;
        scrollbar-color: #20b2aa #f0f8ff;
        user-select: text;
    }
    #textEditor::-webkit-scrollbar, #savedTextList::-webkit-scrollbar {
        width: 16px;
    }
    #textEditor::-webkit-scrollbar-track, #savedTextList::-webkit-scrollbar-track {
        background: #f0f8ff;
        border-radius: 8px;
    }
    #textEditor::-webkit-scrollbar-thumb, #savedTextList::-webkit-scrollbar-thumb {
        background-color: #20b2aa;
        border-radius: 8px;
        border: 2px solid #f0f8ff;
        min-height: 60px;
    }
    #drawingCanvas, #overlayCanvas {
        touch-action: auto;
        position: absolute;
        top: 10px;
        left: 10px;
        height: 100%;
        width: 100%;
        transition: opacity 0.5s ease-out;
    }
    #drawingCanvas.locked, #overlayCanvas.locked {
        touch-action: auto;
    }
    #overlayCanvas {
        background: transparent;
        z-index: 1;
    }
    .pen-options {
        display: flex;
        gap: 8px;
        margin-top: 8px;
    }
    .pen-options select {
        padding: 8px;
        font-size: 14px;
        border-radius: 8px;
        border: 2px solid #20b2aa;
        background-color: #f0fff0;
    }
    .hidden {
        display: none;
    }
    #savedTextList {
        overflow-y: auto;
        padding: 10px;
    }
    .saved-text-item {
        padding: 10px;
        border-bottom: 2px solid #ffd700;
        cursor: pointer;
        font-size: 16px;
        background-color: #f0fff0;
        border-radius: 8px;
        margin-bottom: 5px;
    }
    .saved-text-item:hover {
        background-color: #e6e6fa;
    }
    .page-controls {
        display: flex;
        gap: 8px;
        margin-top: 8px;
    }
    .page-controls select, .page-controls button {
        padding: 8px;
        font-size: 14px;
        border-radius: 8px;
        border: 2px solid #20b2aa;
        background-color: #f0fff0;
        cursor: pointer;
    }
    .back-button, .view-trash-button {
        position: absolute;
        padding: 8px;
        font-size: 14px;
        border-radius: 8px;
        border: 2px solid #20b2aa;
        background-color: #f0fff0;
        cursor: pointer;
    }
    .back-button {
        top: 10px;
        left: 10px;
    }
    .view-trash-button {
        top: 10px;
        right: 10px;
    }
    #progressBarContainer {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        max-width: 400px;
        background-color: #fffacd;
        border: 2px solid #ffd700;
        border-radius: 8px;
        padding: 10px;
        display: none;
        z-index: 1000;
    }
    #progressBar {
        width: 100%;
        height: 20px;
        background-color: #7fffd4;
        border-radius: 4px;
        overflow: hidden;
    }
    #progressFill {
        height: 100%;
        background-color: #20b2aa;
        width: 0%;
        transition: width 0.2s ease-in-out;
    }
    #progressText {
        text-align: center;
        font-size: 14px;
        margin-top: 5px;
        color: #333;
    }
    </style>
</head>
<body>
<div class="container">
    <div class="tabs" id="tabs">
        <div class="tab active" onclick="toggleSection('text')">üìù Write</div>
        <div class="tab" onclick="toggleSection('drawing')">üé® Draw</div>
    </div>
    <div class="toolbar" id="toolbar">
        <div class="toolbar-group" id="textTools">
            <button title="Undo" onclick="undoText()">‚Ü∫</button>
            <button title="Redo" onclick="redoText()">‚Üª</button>
            <button title="Find and Replace" onclick="findAndReplace()">üîé</button>
            <button title="Select All" onclick="selectAll()">üìÑ</button>
            <button title="Copy" onclick="copyText()">üìã</button>
            <button title="Erase Text" onclick="eraseText()">üßπ</button>
            <button title="Save Text" onclick="saveText()">üíæ</button>
            <button title="Show Saved Texts" onclick="showSavedTexts()">üìö</button>
            <button title="Delete Saved Text" onclick="deleteSavedText()">üóëÔ∏è</button>
            <button title="Restore Text" onclick="restoreText()">üîÑ</button>
            <button title="Permanently Delete" onclick="permanentlyDelete()">üóëÔ∏èüö´</button>
            <button title="Open File" onclick="openFile()">üìú</button>
            <button title="Export Text" onclick="exportText()">üì§</button>
        </div>
        <div class="toolbar-group hidden" id="drawingTools">
            <button title="Toggle Drawing" id="drawButton" onclick="toggleDrawing()">‚úçÔ∏è</button>
            <button title="Eraser" id="eraseButton" onclick="toggleErase()">üßπ</button>
            <button title="Lock View" id="lockButton" onclick="toggleLock()">üîí</button>
            <button title="Reset Position" onclick="resetPosition()">üîÑ</button>
            <button title="New Page" onclick="newCanvasPage()">‚ûï</button>
            <button title="Clear Current Page" onclick="clearCurrentPage()">üóëÔ∏è</button>
            <button title="Undo" onclick="undo()">‚Ü∫</button>
            <button title="Redo" onclick="redo()">‚Üª</button>
            <button title="Fill Canvas" onclick="fillCanvas()">üé®</button>
            <button title="Save as JPG" onclick="saveAsJPG()">üñºÔ∏è</button>
            <button title="Share as PDF" onclick="shareAsPDF()">üìÑ</button>
            <div class="pen-options">
                <select id="penWidth" onchange="setPenWidth(this.value)">
                    <option value="5">normal</option>
                    <option value="10">Thick</option>
                    <option value="15">Very Thick</option>
                    <option value="20">large</option>
                    <option value="25">very large</option>
                    <option value="30">Ultra Thick</option>
                </select>
                <select id="penColor" onchange="setPenColor(this.value)">
                    <option value="#ff0000">Red</option>
                    <option value="#0000ff">Blue</option>
                    <option value="#008000">Green</option>
                    <option value="#ffff00">Yellow</option>
                    <option value="#ff69b4">Pink</option>
                    <option value="#800080">Purple</option>
                    <option value="#ffa500">Orange</option>
                    <option value="#000000">Black</option>
                </select>
            </div>
            <div class="page-controls">
                <button onclick="previousPage()">Previous</button>
                <select id="pageSelector" onchange="renderPage(this.value)"></select>
                <button onclick="nextPage()">Next</button>
            </div>
        </div>
    </div>
    <div class="content" id="content">
        <textarea id="textEditor"></textarea>
        <canvas id="drawingCanvas" class="hidden"></canvas>
        <canvas id="overlayCanvas" class="hidden"></canvas>
        <div id="savedTextList" class="hidden"></div>
        <div id="progressBarContainer" class="hidden">
            <div id="progressText">Loading PDF...</div>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
    // Inline Service Worker Registration
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            const swCode = `
                const CACHE_NAME = 'notepad-cache-v17';
                const urlsToCache = [
                    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js',
                    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js',
                    'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js'
                ];

                self.addEventListener('install', event => {
                    event.waitUntil(
                        caches.open(CACHE_NAME)
                            .then(cache => cache.addAll(urlsToCache))
                            .then(() => self.skipWaiting())
                            .catch(err => console.error('Cache open failed:', err))
                    );
                });

                self.addEventListener('activate', event => {
                    event.waitUntil(
                        caches.keys().then(cacheNames => {
                            return Promise.all(
                                cacheNames.filter(name => name !== CACHE_NAME)
                                    .map(name => caches.delete(name))
                            );
                        }).then(() => self.clients.claim())
                    );
                });

                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request)
                            .then(response => {
                                if (response) {
                                    return response;
                                }
                                return fetch(event.request).then(networkResponse => {
                                    if (!networkResponse || networkResponse.status !== 200 || networkResponse.type !== 'basic') {
                                        return networkResponse;
                                    }
                                    const responseToCache = networkResponse.clone();
                                    caches.open(CACHE_NAME).then(cache => {
                                        cache.put(event.request, responseToCache);
                                    });
                                    return networkResponse;
                                }).catch(() => {
                                    console.error('Fetch failed for:', event.request.url);
                                    return new Response('Resource not available offline', { status: 404 });
                                });
                            })
                    );
                });
            `;
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            navigator.serviceWorker.register(url)
                .then(reg => console.log('Service Worker registered'))
                .catch(err => console.error('Service Worker registration failed:', err));
        });
    }

    // Set PDF.js worker source
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';

    // IndexedDB Setup
    const DB_NAME = 'KidsNotepadDB';
    const DB_VERSION = 1;
    let db;

    function initIndexedDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                db = event.target.result;
                db.createObjectStore('savedTexts', { keyPath: 'id' });
                db.createObjectStore('deletedTexts', { keyPath: 'id' });
                db.createObjectStore('canvasPages', { keyPath: 'id' });
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                if (navigator.storage && navigator.storage.persist) {
                    navigator.storage.persist().then(granted => {
                        if (granted) {
                            console.log('Persistent storage granted');
                        } else {
                            console.log('Persistent storage not granted');
                        }
                    });
                }
                resolve(db);
            };

            request.onerror = (event) => {
                console.error('IndexedDB error:', event.target.error);
                reject(event.target.error);
            };
        });
    }

    async function getAllFromStore(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = () => {
                const result = {};
                request.result.forEach(item => {
                    result[item.id] = item;
                });
                resolve(result);
            };

            request.onerror = () => reject(request.error);
        });
    }

    async function putToStore(storeName, data) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put(data);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    async function deleteFromStore(storeName, id) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(id);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    let currentSection = 'text';
    let isTextCollapsed = false;
    let isDrawingCollapsed = false;
    let canvasPages = [];
    let currentPageIndex = 0;
    let isDrawing = false;
    let isErasing = false;
    let isLocked = false;
    let penWidth = 5;
    let penColor = "#008000";
    let savedTexts = {};
    let deletedTexts = {};
    let canvasContext = null;
    let overlayContext = null;
    let undoStack = [];
    let redoStack = [];
    let textUndoStack = [];
    let textRedoStack = [];
    let textChangeTimeout = null;
    let strokePoints = [];
    let currentPdf = null;
    let pdfPageCount = 0;
    let lastPoint = null;
    let lastTime = 0;
    let touchStartX = 0;
    let touchStartY = 0;

    // Initialize canvases
    const canvas = document.getElementById('drawingCanvas');
    const overlayCanvas = document.getElementById('overlayCanvas');
    canvasContext = canvas.getContext('2d', { willReadFrequently: true });
    overlayContext = overlayCanvas.getContext('2d', { willReadFrequently: true });
    canvasPages = [document.createElement('canvas')];
    currentPageIndex = 0;
    resizeCanvas();

    // Initialize text editor
    const textEditor = document.getElementById('textEditor');
    const savedTextList = document.getElementById('savedTextList');
    textUndoStack.push(textEditor.value);
    textEditor.addEventListener('input', optimizeTextInput);

    // Initialize IndexedDB and load data
    initIndexedDB().then(() => {
        Promise.all([
            getAllFromStore('savedTexts').then(data => savedTexts = data),
            getAllFromStore('deletedTexts').then(data => deletedTexts = data)
        ]).catch(err => console.error('Failed to load data from IndexedDB:', err));
    });

    // Optimize text input for large amounts of text
    function optimizeTextInput() {
        clearTimeout(textChangeTimeout);
        textChangeTimeout = setTimeout(() => {
            if (textEditor.value !== textUndoStack[textUndoStack.length - 1]) {
                saveTextState();
            }
        }, 300);
    }

    // Drawing, erasing, and lock toggle
    function toggleDrawing() {
        if (isLocked) return;
        isDrawing = !isDrawing;
        isErasing = false;
        const drawButton = document.getElementById('drawButton');
        const eraseButton = document.getElementById('eraseButton');
        drawButton.classList.toggle('active', isDrawing);
        eraseButton.classList.remove('active');
    }

    function toggleErase() {
        if (isLocked) return;
        isErasing = !isErasing;
        isDrawing = false;
        const drawButton = document.getElementById('drawButton');
        const eraseButton = document.getElementById('eraseButton');
        eraseButton.classList.toggle('active', isErasing);
        drawButton.classList.remove('active');
    }

    function toggleLock() {
        isLocked = !isLocked;
        const lockButton = document.getElementById('lockButton');
        const drawButton = document.getElementById('drawButton');
        const eraseButton = document.getElementById('eraseButton');
        const content = document.getElementById('content');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const overlayCanvas = document.getElementById('overlayCanvas');

        lockButton.classList.toggle('active', isLocked);
        if (isLocked) {
            isDrawing = false;
            isErasing = false;
            drawButton.classList.remove('active');
            eraseButton.classList.remove('active');
            content.classList.add('locked');
            drawingCanvas.classList.add('locked');
            overlayCanvas.classList.add('locked');
        } else {
            content.classList.remove('locked');
            drawingCanvas.classList.remove('locked');
            overlayCanvas.classList.remove('locked');
        }
    }

    function resetPosition() {
        resizeCanvas();
    }

    // Tab switching and collapsing
    function toggleSection(section) {
        const tabs = document.getElementById('tabs');
        const toolbar = document.getElementById('toolbar');
        const content = document.getElementById('content');

        if (section === 'text') {
            if (currentSection === 'text') {
                isTextCollapsed = !isTextCollapsed;
                if (isTextCollapsed) {
                    toolbar.classList.add('hidden');
                    content.classList.add('fullscreen');
                } else {
                    toolbar.classList.remove('hidden');
                    content.classList.remove('fullscreen');
                }
                showSection('text');
            } else {
                isTextCollapsed = false;
                isDrawingCollapsed = false;
                isLocked = false;
                toolbar.classList.remove('hidden');
                content.classList.remove('fullscreen');
                content.classList.remove('locked');
                document.getElementById('lockButton').classList.remove('active');
                showSection('text');
            }
        } else if (section === 'drawing') {
            if (currentSection === 'drawing') {
                isDrawingCollapsed = !isDrawingCollapsed;
                if (isDrawingCollapsed) {
                    toolbar.classList.add('hidden');
                    content.classList.add('fullscreen');
                } else {
                    toolbar.classList.remove('hidden');
                    content.classList.remove('fullscreen');
                }
                showSection('drawing');
            } else {
                isDrawingCollapsed = false;
                isTextCollapsed = false;
                isLocked = false;
                toolbar.classList.remove('hidden');
                content.classList.remove('fullscreen');
                content.classList.remove('locked');
                document.getElementById('lockButton').classList.remove('active');
                showSection('drawing');
            }
        }
    }

    function showSection(section) {
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        document.querySelector(`.tab[onclick="toggleSection('${section}')"]`).classList.add('active');
        document.getElementById('textEditor').classList.add('hidden');
        document.getElementById('drawingCanvas').classList.add('hidden');
        document.getElementById('overlayCanvas').classList.add('hidden');
        document.getElementById('savedTextList').classList.add('hidden');
        document.getElementById('progressBarContainer').classList.add('hidden');
        document.getElementById('textTools').classList.add('hidden');
        document.getElementById('drawingTools').classList.remove('hidden');
        
        if (section === 'text') {
            document.getElementById('textEditor').classList.remove('hidden');
            document.getElementById('textTools').classList.remove('hidden');
            document.getElementById('drawingTools').classList.add('hidden');
            isDrawing = false;
            isErasing = false;
            isLocked = false;
            document.getElementById('drawButton').classList.remove('active');
            document.getElementById('eraseButton').classList.remove('active');
            document.getElementById('lockButton').classList.remove('active');
            document.getElementById('content').classList.remove('locked');
            document.getElementById('drawingCanvas').classList.remove('locked');
            document.getElementById('overlayCanvas').classList.remove('locked');
        } else {
            document.getElementById('drawingCanvas').classList.remove('hidden');
            document.getElementById('overlayCanvas').classList.remove('hidden');
            setTimeout(() => resizeCanvas(), 100);
        }
        currentSection = section;
        redrawCanvas();
    }

    // Text Undo/Redo Functions
    function saveTextState() {
        textUndoStack.push(textEditor.value);
        if (textUndoStack.length > 50) textUndoStack.shift();
        textRedoStack = [];
    }

    function undoText() {
        if (textUndoStack.length <= 1) return;
        const currentText = textEditor.value;
        textRedoStack.push(currentText);
        if (textRedoStack.length > 50) textRedoStack.shift();
        textUndoStack.pop();
        textEditor.value = textUndoStack[textUndoStack.length - 1] || '';
    }

    function redoText() {
        if (textRedoStack.length === 0) return;
        const currentText = textEditor.value;
        textUndoStack.push(currentText);
        if (textUndoStack.length > 50) textUndoStack.shift();
        textEditor.value = textRedoStack.pop();
    }

    // Text Editor Functions
    function findAndReplace() {
        saveTextState();
        const find = prompt('Find what?');
        if (!find) return;
        const replace = prompt('Replace with?');
        textEditor.value = textEditor.value.replace(new RegExp(find, 'g'), replace);
        saveTextState();
    }

    function selectAll() {
        textEditor.select();
    }

    function copyText() {
        textEditor.select();
        navigator.clipboard.writeText(textEditor.value).catch(err => console.error('Copy failed:', err));
    }

    function eraseText() {
        saveTextState();
        textEditor.value = '';
        saveTextState();
    }

    async function saveText() {
        const text = textEditor.value;
        const id = Date.now().toString();
        try {
            await putToStore('savedTexts', { id, text, date: new Date() });
            savedTexts[id] = { text, date: new Date() };
            alert('Text saved! ID: ' + id);
        } catch (err) {
            console.error('Failed to save text:', err);
            alert('Failed to save text!');
        }
    }

    async function showSavedTexts() {
        document.getElementById('textEditor').classList.add('hidden');
        document.getElementById('savedTextList').classList.remove('hidden');
        try {
            savedTexts = await getAllFromStore('savedTexts');
            renderTextList('view');
        } catch (err) {
            console.error('Failed to load saved texts:', err);
            alert('Failed to load saved texts!');
        }
    }

    async function renderTextList(mode) {
        const list = document.getElementById('savedTextList');
        list.innerHTML = '';
        const texts = mode === 'permanentlyDelete' || mode === 'restore' ? deletedTexts : savedTexts;
        const isEmpty = Object.keys(texts).length === 0;
        
        if (isEmpty) {
            const div = document.createElement('div');
            div.className = 'saved-text-item';
            div.innerText = mode === 'permanentlyDelete' || mode === 'restore' ? 'No texts in trash!' : 'No saved texts!';
            list.appendChild(div);
        } else {
            for (const id in texts) {
                const div = document.createElement('div');
                div.className = 'saved-text-item';
                div.innerText = `ID: ${id} | Date: ${new Date(texts[id].date).toLocaleString()} | ${texts[id].text.slice(0, 50)}...`;
                div.onclick = async () => {
                    if (mode === 'delete') {
                        try {
                            deletedTexts[id] = savedTexts[id];
                            await putToStore('deletedTexts', deletedTexts[id]);
                            await deleteFromStore('savedTexts', id);
                            delete savedTexts[id];
                            alert('Text moved to trash!');
                            renderTextList('delete');
                        } catch (err) {
                            console.error('Failed to delete text:', err);
                            alert('Failed to delete text!');
                        }
                    } else if (mode === 'restore') {
                        const now = new Date();
                        const deletedDate = new Date(deletedTexts[id].date);
                        const daysDiff = (now - deletedDate) / (1000 * 60 * 60 * 24);
                        if (daysDiff <= 60) {
                            try {
                                saveTextState();
                                savedTexts[id] = deletedTexts[id];
                                await putToStore('savedTexts', savedTexts[id]);
                                await deleteFromStore('deletedTexts', id);
                                delete deletedTexts[id];
                                textEditor.value = savedTexts[id].text;
                                saveTextState();
                                alert('Text restored!');
                                showSection('text');
                            } catch (err) {
                                console.error('Failed to restore text:', err);
                                alert('Failed to restore text!');
                            }
                        } else {
                            alert('Text is older than 60 days!');
                        }
                    } else if (mode === 'permanentlyDelete') {
                        try {
                            await deleteFromStore('deletedTexts', id);
                            delete deletedTexts[id];
                            alert('Text permanently deleted!');
                            renderTextList('permanentlyDelete');
                        } catch (err) {
                            console.error('Failed to permanently delete text:', err);
                            alert('Failed to permanently delete text!');
                        }
                    } else {
                        saveTextState();
                        textEditor.value = savedTexts[id].text;
                        saveTextState();
                        showSection('text');
                    }
                };
                list.appendChild(div);
            }
        }
        
        const backButton = document.createElement('button');
        backButton.className = 'back-button';
        backButton.innerText = 'Back';
        backButton.onclick = () => showSection('text');
        list.insertBefore(backButton, list.firstChild);

        if (mode === 'restore') {
            const viewTrashButton = document.createElement('button');
            viewTrashButton.className = 'view-trash-button';
            viewTrashButton.innerText = 'View Trash';
            viewTrashButton.onclick = () => renderTextList('permanentlyDelete');
            list.insertBefore(viewTrashButton, list.firstChild);
        }
    }

    async function deleteSavedText() {
        document.getElementById('textEditor').classList.add('hidden');
        document.getElementById('savedTextList').classList.remove('hidden');
        try {
            deletedTexts = await getAllFromStore('deletedTexts');
            renderTextList('delete');
        } catch (err) {
            console.error('Failed to load deleted texts:', err);
            alert('Failed to load deleted texts!');
        }
    }

    async function restoreText() {
        document.getElementById('textEditor').classList.add('hidden');
        document.getElementById('savedTextList').classList.remove('hidden');
        try {
            deletedTexts = await getAllFromStore('deletedTexts');
            renderTextList('restore');
        } catch (err) {
            console.error('Failed to load deleted texts:', err);
            alert('Failed to load deleted texts!');
        }
    }

    async function permanentlyDelete() {
        document.getElementById('textEditor').classList.add('hidden');
        document.getElementById('savedTextList').classList.remove('hidden');
        try {
            deletedTexts = await getAllFromStore('deletedTexts');
            renderTextList('permanentlyDelete');
        } catch (err) {
            console.error('Failed to load deleted texts:', err);
            alert('Failed to load deleted texts!');
        }
    }

    function exportText() {
        const text = textEditor.value;
        const blob = new Blob([text], { type: 'text/plain' });
        downloadFile(blob, 'notepad.txt');
    }

    // File Handling
    async function openFile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/pdf,.txt';
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            saveTextState();
            const progressBarContainer = document.getElementById('progressBarContainer');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            progressBarContainer.classList.remove('hidden');
            progressFill.style.width = '0%';
            progressText.textContent = 'Loading file...';

            if (file.type === 'text/plain') {
                progressText.textContent = 'Loading text file...';
                const text = await file.text();
                textEditor.value = text;
                saveTextState();
                progressBarContainer.classList.add('hidden');
                showSection('text');
            } else if (file.type === 'application/pdf') {
                try {
                    currentPdf = null;
                    pdfPageCount = 0;
                    canvasPages = [];
                    currentPageIndex = 0;
                    undoStack = [];
                    redoStack = [];
                    overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                    const arrayBuffer = await file.arrayBuffer();
                    const loadingTask = pdfjsLib.getDocument({
                        data: arrayBuffer,
                        disableAutoFetch: true,
                        disableStream: true,
                        disableFontFace: true,
                        nativeImageDecoderSupport: 'decode',
                        maxImageSize: 1024 * 1024,
                        isEvalSupported: false
                    });

                    let totalSteps = 2;
                    let currentStep = 0;

                    function updateProgress(step, total) {
                        currentStep = step;
                        const percent = Math.min(100, (currentStep / total) * 100);
                        progressFill.style.width = `${percent}%`;
                        progressText.textContent = `Processing PDF (${currentStep}/${total})...`;
                    }

                    updateProgress(0, totalSteps);
                    loadingTask.onProgress = (progress) => {
                        if (progress.total) {
                            const percent = Math.min(100, (progress.loaded / progress.total) * 50);
                            progressFill.style.width = `${percent}%`;
                        }
                    };

                    currentPdf = await loadingTask.promise;
                    pdfPageCount = currentPdf.numPages;
                    updateProgress(1, totalSteps);

                    let textContent = '';
                    for (let i = 1; i <= pdfPageCount; i++) {
                        const page = await currentPdf.getPage(i);
                        const text = await page.getTextContent();
                        textContent += text.items.map(item => item.str + (item.hasEOL ? '\n' : ' ')).join('');
                        if (i < pdfPageCount) textContent += '\n\n';
                    }
                    textContent = textContent.trim();

                    if (textContent.length > 0) {
                        textEditor.value = textContent;
                        saveTextState();
                        updateProgress(2, totalSteps);
                        progressBarContainer.classList.add('hidden');
                        showSection('text');
                        currentPdf = null;
                    } else {
                        totalSteps = pdfPageCount + 2;
                        updateProgress(2, totalSteps);

                        const selector = document.getElementById('pageSelector');
                        selector.innerHTML = '';
                        for (let i = 1; i <= pdfPageCount; i++) {
                            const option = document.createElement('option');
                            option.value = i;
                            option.text = `Page ${i}`;
                            selector.appendChild(option);
                        }
                        canvasPages = Array(pdfPageCount).fill().map(() => document.createElement('canvas'));
                        progressBarContainer.classList.add('hidden');
                        isLocked = true; // Open in lock mode by default
                        document.getElementById('lockButton').classList.add('active');
                        document.getElementById('content').classList.add('locked');
                        document.getElementById('drawingCanvas').classList.add('locked');
                        document.getElementById('overlayCanvas').classList.add('locked');
                        showSection('drawing');
                        renderPage(1);
                    }
                } catch (err) {
                    console.error('PDF loading failed:', err);
                    progressBarContainer.classList.add('hidden');
                    let errorMessage = 'Failed to load PDF!';
                    if (err.name === 'InvalidPDFException') {
                        errorMessage = 'Invalid or corrupted PDF file!';
                    } else if (err.message.includes('network')) {
                        errorMessage = 'Network error: Please check your connection or try again!';
                    }
                    alert(errorMessage);
                    currentPdf = null;
                }
            }
        };
        input.click();
    }

    function previousPage() {
        if (currentPageIndex > 0) {
            putToStore('canvasPages', { id: `canvasPage_${currentPageIndex}`, dataURL: overlayCanvas.toDataURL() })
                .then(() => {
                    currentPageIndex--;
                    document.getElementById('pageSelector').value = currentPageIndex + 1;
                    renderPage(currentPageIndex + 1);
                })
                .catch(err => console.error('Failed to save canvas page:', err));
        }
    }

    function nextPage() {
        if (currentPageIndex < canvasPages.length - 1) {
            putToStore('canvasPages', { id: `canvasPage_${currentPageIndex}`, dataURL: overlayCanvas.toDataURL() })
                .then(() => {
                    currentPageIndex++;
                    document.getElementById('pageSelector').value = currentPageIndex + 1;
                    renderPage(currentPageIndex + 1);
                })
                .catch(err => console.error('Failed to save canvas page:', err));
        }
    }

    async function renderPage(pageNum) {
        currentPageIndex = pageNum - 1;
        const content = document.querySelector('.content');
        let imgWidth = content.offsetWidth;
        let imgHeight = content.offsetHeight;

        if (currentPdf && currentPageIndex < pdfPageCount) {
            const page = await currentPdf.getPage(pageNum);
            const viewport = page.getViewport({ scale: 3 });
            imgWidth = viewport.width;
            imgHeight = viewport.height;
            canvasPages[currentPageIndex].width = imgWidth;
            canvasPages[currentPageIndex].height = imgHeight;
            const ctx = canvasPages[currentPageIndex].getContext('2d', { willReadFrequently: true });
            ctx.clearRect(0, 0, imgWidth, imgHeight);
            await page.render({
                canvasContext: ctx,
                viewport: viewport,
                enableWebGL: true
            }).promise;
        } else {
            canvasPages[currentPageIndex].width = imgWidth;
            canvasPages[currentPageIndex].height = imgHeight;
            const ctx = canvasPages[currentPageIndex].getContext('2d', { willReadFrequently: true });
            ctx.clearRect(0, 0, imgWidth, imgHeight);
        }

        canvas.width = imgWidth;
        canvas.height = imgHeight;
        overlayCanvas.width = content.offsetWidth;
        overlayCanvas.height = content.offsetHeight;
        canvasPages[currentPageIndex].width = canvas.width;
        canvasPages[currentPageIndex].height = canvas.height;

        try {
            const transaction = db.transaction(['canvasPages'], 'readonly');
            const store = transaction.objectStore('canvasPages');
            const request = store.get(`canvasPage_${currentPageIndex}`);
            request.onsuccess = () => {
                const savedCanvas = request.result;
                if (savedCanvas && savedCanvas.dataURL) {
                    const img = new Image();
                    img.src = savedCanvas.dataURL;
                    img.onload = () => {
                        overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                        overlayContext.drawImage(img, 0, 0);
                        redrawCanvas();
                    };
                    img.onerror = () => {
                        overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                        redrawCanvas();
                    };
                } else {
                    overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                    redrawCanvas();
                }
            };
            request.onerror = () => {
                console.error('Failed to load canvas page:', request.error);
                overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                redrawCanvas();
            };
        } catch (err) {
            console.error('Failed to load canvas page:', err);
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            redrawCanvas();
        }
    }

    // File download helper
    function downloadFile(blob, filename) {
        try {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        } catch (err) {
            console.error('Download failed:', err);
            alert('Failed to download file. Please try again.');
        }
    }

    // Save as JPG
    async function saveAsJPG() {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const ctx = tempCanvas.getContext('2d');

        if (currentPdf && currentPageIndex < pdfPageCount) {
            const page = await currentPdf.getPage(currentPageIndex + 1);
            const viewport = page.getViewport({ scale: 3 });
            tempCanvas.width = viewport.width;
            tempCanvas.height = viewport.height;
            await page.render({
                canvasContext: ctx,
                viewport: viewport,
                enableWebGL: true
            }).promise;
        } else {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        }

        ctx.drawImage(overlayCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
        const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png', 0.95));
        downloadFile(blob, `drawing_page_${currentPageIndex + 1}.jpg`);
    }

    // Share as PDF
    async function shareAsPDF() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'px',
            format: 'a4'
        });
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();

        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        progressBarContainer.classList.remove('hidden');
        progressFill.style.width = '0%';
        progressText.textContent = 'Generating PDF...';

        for (let i = 0; i < canvasPages.length; i++) {
            if (i > 0) doc.addPage();
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvasPages[i].width;
            tempCanvas.height = canvasPages[i].height;
            const ctx = tempCanvas.getContext('2d');

            if (currentPdf && i < pdfPageCount) {
                const page = await currentPdf.getPage(i + 1);
                const viewport = page.getViewport({ scale: 3 });
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                await page.render({
                    canvasContext: ctx,
                    viewport: viewport,
                    enableWebGL: true
                }).promise;
            } else {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            }

            try {
                const transaction = db.transaction(['canvasPages'], 'readonly');
                const store = transaction.objectStore('canvasPages');
                const request = store.get(`canvasPage_${i}`);
                await new Promise(resolve => {
                    request.onsuccess = () => {
                        const savedCanvas = request.result;
                        if (savedCanvas && savedCanvas.dataURL) {
                            const img = new Image();
                            img.src = savedCanvas.dataURL;
                            img.onload = () => {
                                ctx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                                resolve();
                            };
                            img.onerror = () => resolve();
                        } else {
                            resolve();
                        }
                    };
                    request.onerror = () => resolve();
                });
            } catch (err) {
                console.error('Failed to load canvas page for PDF:', err);
                resolve();
            }

            const imgData = tempCanvas.toDataURL('image/jpeg', 0.95);
            const imgProps = doc.getImageProperties(imgData);
            const imgWidth = pageWidth - 20;
            const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
            const yPos = (pageHeight - imgHeight) / 2;
            doc.addImage(imgData, 'JPEG', 10, yPos, imgWidth, imgHeight);

            const percent = ((i + 1) / canvasPages.length) * 100;
            progressFill.style.width = `${percent}%`;
            progressText.textContent = `Generating PDF (${i + 1}/${canvasPages.length})...`;
        }

        progressBarContainer.classList.add('hidden');
        const blob = doc.output('blob');
        downloadFile(blob, 'notepad_drawing.pdf');
    }

    // Canvas Drawing
    function resizeCanvas() {
        const content = document.querySelector('.content');
        let imgWidth = content.offsetWidth;
        let imgHeight = content.offsetHeight;

        if (currentPdf && currentPageIndex < pdfPageCount) {
            imgWidth = canvasPages[currentPageIndex].width || imgWidth;
            imgHeight = canvasPages[currentPageIndex].height || imgHeight;
        }

        canvas.width = imgWidth;
        canvas.height = imgHeight;
        overlayCanvas.width = content.offsetWidth;
        overlayCanvas.height = content.offsetHeight;
        canvasPages[currentPageIndex].width = canvas.width;
        canvasPages[currentPageIndex].height = canvas.height;
        canvasPages[currentPageIndex].getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        try {
            const transaction = db.transaction(['canvasPages'], 'readonly');
            const store = transaction.objectStore('canvasPages');
            const request = store.get(`canvasPage_${currentPageIndex}`);
            request.onsuccess = () => {
                const savedCanvas = request.result;
                if (savedCanvas && savedCanvas.dataURL) {
                    const img = new Image();
                    img.src = savedCanvas.dataURL;
                    img.onload = () => {
                        overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                        overlayContext.drawImage(img, 0, 0);
                        redrawCanvas();
                    };
                } else {
                    overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                    redrawCanvas();
                }
            };
            request.onerror = () => {
                console.error('Failed to load canvas page:', request.error);
                overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                redrawCanvas();
            };
        } catch (err) {
            console.error('Failed to load canvas page:', err);
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            redrawCanvas();
        }
    }

    function addCanvasPage() {
        const content = document.querySelector('.content');
        const dataURL = overlayCanvas.toDataURL();
        putToStore('canvasPages', { id: `canvasPage_${currentPageIndex}`, dataURL })
            .then(() => {
                const newCanvas = document.createElement('canvas');
                newCanvas.width = content.offsetWidth;
                newCanvas.height = content.offsetHeight;
                // Insert new blank page after the current page
                canvasPages.splice(currentPageIndex + 1, 0, newCanvas);
                currentPageIndex = currentPageIndex + 1;
                const selector = document.getElementById('pageSelector');
                selector.innerHTML = '';
                for (let i = 1; i <= canvasPages.length; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.text = `Page ${i}`;
                    selector.appendChild(option);
                }
                selector.value = currentPageIndex + 1;
                undoStack = [];
                redoStack = [];
                overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                putToStore('canvasPages', { id: `canvasPage_${currentPageIndex}`, dataURL: overlayCanvas.toDataURL() })
                    .then(() => redrawCanvas())
                    .catch(err => console.error('Failed to save new canvas page:', err));
            })
            .catch(err => console.error('Failed to save canvas page:', err));
    }

    function newCanvasPage() {
        addCanvasPage();
        resizeCanvas();
    }

    function clearCurrentPage() {
        saveCanvasState();
        overlayCanvas.style.opacity = '0';
        setTimeout(() => {
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            putToStore('canvasPages', { id: `canvasPage_${currentPageIndex}`, dataURL: overlayCanvas.toDataURL() })
                .then(() => {
                    undoStack = [];
                    redoStack = [];
                    overlayCanvas.style.opacity = '1';
                    const currentCanvas = canvasPages[currentPageIndex];
                    const ctx = currentCanvas.getContext('2d');
                    const imageData = ctx.getImageData(0, 0, currentCanvas.width, currentCanvas.height).data;
                    const isEmpty = Array.from(imageData).every(pixel => pixel === 0 || pixel === 255);
                    if (isEmpty && canvasPages.length > 1 && currentPageIndex >= pdfPageCount) {
                        canvasPages.splice(currentPageIndex, 1);
                        deleteFromStore('canvasPages', `canvasPage_${currentPageIndex}`)
                            .then(() => {
                                if (currentPageIndex >= canvasPages.length) {
                                    currentPageIndex = canvasPages.length - 1;
                                }
                                const selector = document.getElementById('pageSelector');
                                selector.innerHTML = '';
                                for (let i = 1; i <= canvasPages.length; i++) {
                                    const option = document.createElement('option');
                                    option.value = i;
                                    option.text = `Page ${i}`;
                                    selector.appendChild(option);
                                }
                                selector.value = currentPageIndex + 1;
                                renderPage(currentPageIndex + 1);
                            })
                            .catch(err => console.error('Failed to delete canvas page:', err));
                    } else {
                        redrawCanvas();
                    }
                })
                .catch(err => console.error('Failed to save cleared canvas:', err));
        }, 500);
    }

    function fillCanvas() {
        saveCanvasState();
        overlayContext.fillStyle = penColor;
        overlayContext.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        redoStack = [];
        putToStore('canvasPages', { id: `canvasPage_${currentPageIndex}`, dataURL: overlayCanvas.toDataURL() })
            .then(() => redrawCanvas())
            .catch(err => console.error('Failed to save filled canvas:', err));
    }

    function setPenWidth(width) {
        penWidth = parseInt(width);
    }

    function setPenColor(color) {
        penColor = color;
    }

    function saveCanvasState(points = []) {
        const dataURL = overlayCanvas.toDataURL();
        const bounds = points.length > 0 ? calculateStrokeBounds(points) : null;
        undoStack.push({ dataURL, points, bounds });
        if (undoStack.length > 50) undoStack.shift();
        putToStore('canvasPages', { id: `canvasPage_${currentPageIndex}`, dataURL })
            .catch(err => console.error('Failed to save canvas state:', err));
    }

    function calculateStrokeBounds(points) {
        if (points.length === 0) return null;
        let minX = points[0].x, maxX = points[0].x;
        let minY = points[0].y, maxY = points[0].y;
        points.forEach(point => {
            minX = Math.min(minX, point.x);
            maxX = Math.max(maxX, point.x);
            minY = Math.min(minY, point.y);
            maxY = Math.max(maxY, point.y);
        });
        return { minX, maxX, minY, maxY };
    }

    function undo() {
        if (undoStack.length === 0) return;
        if (undoStack.length === 1) {
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            putToStore('canvasPages', { id: `canvasPage_${currentPageIndex}`, dataURL: overlayCanvas.toDataURL() })
                .then(() => {
                    undoStack = [];
                    redoStack = [];
                    redrawCanvas();
                })
                .catch(err => console.error('Failed to save canvas undo:', err));
            return;
        }
        const currentState = overlayCanvas.toDataURL();
        redoStack.push({ dataURL: currentState, points: [], bounds: null });
        if (redoStack.length > 50) redoStack.shift();
        const prevState = undoStack.pop();
        const img = new Image();
        img.src = prevState.dataURL;
        img.onload = () => {
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            overlayContext.drawImage(img, 0, 0);
            putToStore('canvasPages', { id: `canvasPage_${currentPageIndex}`, dataURL: overlayCanvas.toDataURL() })
                .then(() => {
                    redrawCanvas();
                    isDrawing = true;
                    isErasing = false;
                    document.getElementById('drawButton').classList.add('active');
                    document.getElementById('eraseButton').classList.remove('active');
                })
                .catch(err => console.error('Failed to save canvas undo:', err));
        };
    }

    function redo() {
        if (redoStack.length === 0) return;
        const currentState = overlayCanvas.toDataURL();
        undoStack.push({ dataURL: currentState, points: [], bounds: null });
        if (undoStack.length > 50) undoStack.shift();
        const nextState = redoStack.pop();
        const img = new Image();
        img.src = nextState.dataURL;
        img.onload = () => {
            overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            overlayContext.drawImage(img, 0, 0);
            putToStore('canvasPages', { id: `canvasPage_${currentPageIndex}`, dataURL: overlayCanvas.toDataURL() })
                .then(() => redrawCanvas())
                .catch(err => console.error('Failed to save canvas redo:', err));
        };
    }

    async function redrawCanvas() {
        if (canvas.width === 0 || canvas.height === 0) return;
        canvasContext.clearRect(0, 0, canvas.width, canvas.height);
        if (currentPdf && currentPageIndex < pdfPageCount) {
            const page = await currentPdf.getPage(currentPageIndex + 1);
            const viewport = page.getViewport({ scale: 3 });
            await page.render({
                canvasContext: canvasContext,
                viewport: viewport,
                enableWebGL: true
            }).promise;
        }
    }

    // Simplified Smooth Drawing Logic
    function getCoordinates(e) {
        const rect = overlayCanvas.getBoundingClientRect();
        let x, y;
        if (e.type.startsWith('touch')) {
            x = e.touches[0].clientX - rect.left;
            y = e.touches[0].clientY - rect.top;
        } else {
            x = e.clientX - rect.left;
            y = e.clientY - rect.top;
        }
        return { x, y, time: Date.now() };
    }

    function drawStroke(currentPoint) {
        if (!lastPoint) return;

        overlayContext.lineCap = 'round';
        overlayContext.lineJoin = 'round';
        overlayContext.strokeStyle = penColor;
        overlayContext.lineWidth = penWidth;
        overlayContext.globalAlpha = 100;

        const deltaTime = currentPoint.time - lastTime;
        const speed = Math.sqrt(
            Math.pow(currentPoint.x - lastPoint.x, 1) +
            Math.pow(currentPoint.y - lastPoint.y, 1)
        ) / (deltaTime || 1);
        const dynamicWidth = Math.max(1, Math.min(penWidth, penWidth / (1 + speed * 0.1)));

        overlayContext.beginPath();
        overlayContext.moveTo(lastPoint.x, lastPoint.y);
        overlayContext.lineTo(currentPoint.x, currentPoint.y);
        overlayContext.lineWidth = dynamicWidth;
        overlayContext.stroke();
        overlayContext.globalAlpha = 100;
    }

    function eraseStroke(x, y) {
        const eraseRadius = penWidth * 5;
        overlayContext.globalCompositeOperation = 'destination-out';
        overlayContext.beginPath();
        overlayContext.arc(x, y, eraseRadius, 0, Math.PI * 2);
        overlayContext.fill();
        overlayContext.globalCompositeOperation = 'source-over';
    }

    function addPoint(e) {
        if (!isDrawing && !isErasing || currentSection !== 'drawing' || isLocked) return;
        const point = getCoordinates(e);
        strokePoints.push(point);

        if (isDrawing) {
            point.color = penColor;
            point.width = penWidth;
            drawStroke(point);
            lastPoint = point;
            lastTime = point.time;
        } else if (isErasing) {
            eraseStroke(point.x, point.y);
        }
        e.preventDefault();
    }

    // Drawing and Swipe Event Listeners
    overlayCanvas.addEventListener('mousedown', (e) => {
        if (currentSection === 'drawing' && isDrawing && !isLocked) {
            lastPoint = getCoordinates(e);
            lastTime = lastPoint.time;
            strokePoints = [lastPoint];
        } else if (currentSection === 'drawing' && isErasing && !isLocked) {
            const point = getCoordinates(e);
            strokePoints = [point];
            eraseStroke(point.x, point.y);
        }
    });

    overlayCanvas.addEventListener('mousemove', (e) => {
        if (currentSection === 'drawing' && isDrawing && !isLocked) {
            addPoint(e);
        } else if (currentSection === 'drawing' && isErasing && !isLocked) {
            const point = getCoordinates(e);
            strokePoints.push(point);
            eraseStroke(point.x, point.y);
        }
    });

    overlayCanvas.addEventListener('mouseup', () => {
        if (currentSection === 'drawing' && (isDrawing || isErasing) && !isLocked && strokePoints.length > 0) {
            saveCanvasState(strokePoints);
            redoStack = [];
            strokePoints = [];
            lastPoint = null;
        }
    });

    overlayCanvas.addEventListener('touchstart', (e) => {
        if (currentSection === 'drawing') {
            if (isLocked && e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (!isLocked && e.touches.length === 1) {
                isDrawing = true;
                isErasing = false;
                document.getElementById('drawButton').classList.add('active');
                document.getElementById('eraseButton').classList.remove('active');
                lastPoint = getCoordinates(e);
                lastTime = lastPoint.time;
                strokePoints = [lastPoint];
            } else if (!isLocked && e.touches.length === 2) {
                isErasing = true;
                isDrawing = false;
                document.getElementById('eraseButton').classList.add('active');
                document.getElementById('drawButton').classList.remove('active');
                const point = getCoordinates(e);
                strokePoints = [point];
                eraseStroke(point.x, point.y);
            } else if (!isLocked && e.touches.length === 3) {
                undo();
                e.preventDefault();
                return;
            }
            e.preventDefault();
        }
    });

    overlayCanvas.addEventListener('touchmove', (e) => {
        if (currentSection === 'drawing' && !isLocked && (e.touches.length === 1 || e.touches.length === 2)) {
            addPoint(e);
            e.preventDefault();
        }
    });

    overlayCanvas.addEventListener('touchend', (e) => {
        if (currentSection === 'drawing' && isLocked && e.changedTouches.length === 1) {
            const touchEndX = e.changedTouches[0].clientX;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchStartY - e.changedTouches[0].clientY;
            const swipeThreshold = 100;
            if (Math.abs(deltaX) > swipeThreshold && Math.abs(deltaY) < swipeThreshold) {
                if (deltaX > 0) {
                    previousPage();
                } else {
                    nextPage();
                }
            }
        } else if (currentSection === 'drawing' && !isLocked && e.changedTouches.length >= 1 && (isDrawing || isErasing) && strokePoints.length > 0) {
            saveCanvasState(strokePoints);
            redoStack = [];
            strokePoints = [];
            lastPoint = null;
        }
        e.preventDefault();
    });

    overlayCanvas.addEventListener('wheel', (e) => {
        if (!isLocked) e.preventDefault();
    });

    // Window resize handling
    window.addEventListener('resize', resizeCanvas);
</script>
</body>
</html>